<!doctype html>
<html>
	<head>
		<title>randomMap</title>
        <meta charset='utf-8' />
	</head>
	<body>
		<table>
		  <tr>
			<td>
		<canvas height='1000' width='1000' id='screen'>randomMap</canvas>
			</td>
			<td align = 'right'>
				<div id='information' >
				</div><br><br>
				<form>
					Количество клеток<br>
					<input type='text' size='3' id='detalization' name='detalization' value='7'><br>
					Шероховатость<br>
					<input type='text' size='3' id='roughness' name='roughness' value='1'><br>
					Возвести высоты в квадрат<br>
					<input type='checkbox' id='do2power' name='do2power' checked><br><br>
			
					Диапазон цветов:<br>
					R <input type='text' size='1' id='initRcolor' name='initRcolor' value='0'> - 
											<input type='text' size='3' id='finRcolor' name='finRcolor' value='0'><br>
					G <input type='text' size='1' id='initGcolor' name='initGcolor' value='90'> - 
											<input type='text' size='3' id='finGcolor' name='finGcolor' value='255'><br>
					B <input type='text' size='1' id='initBcolor' name='initBcolor' value='30'> - 
											<input type='text' size='3' id='finBcolor' name='finBcolor' value='40'><br><br>
			
					Высота за границей<br>
					<input type='text' size='3' id='outsideHeight' name='outsideHeight' value='0'><br>
					Уровень моря<br>
					<input type='text' size='3' id='waterLevel' name='waterLevel' value='0.001'><br><br>
					<input type='button' value='Новая карта' id='newMap' name='newMap' >
				</form>
			</td>
		  </tr>
		</table>
		<script>
			'use strict';

			Array.matrix = function (m, n, initial) {
				var a, i, j, mat = [];
				for (i = 0; i < m; i += 1) {
					a = [];
					for (j = 0; j < n; j += 1) {
						a[j] = initial;
					}
					mat[i] = a;
				}
				return mat;
			};
			
			function Terrain(detalization) {
				this.size = Math.pow(2, detalization) + 1;
				this.max = this.size - 1;
				this.map = Array.matrix(this.size, this.size, 0);
				this.colors = Array.matrix(this.size, this.size, 0);
			}
			
		
			var newMapButton = document.getElementById('newMap');	
			newMapButton.onclick = function() {
				var startTime = Date.now();
				
				checkFieldsAreCorrect();
				
				var detalization = getValue('detalization');
				var roughness = getValue('roughness');
				
				var screen = document.getElementById('screen');
				var	ctx = screen.getContext('2d');				
				var canvas = document.getElementsByTagName('canvas')[0];
				canvas.width  = (Math.pow(2, detalization) + 1) * Math.pow(2, 10 - +detalization);
				canvas.height = canvas.width;
				
				var terrain = new Terrain(detalization);			
                terrain.generate(roughness);				
				terrain.defineColors();
			//	terrain.draw(ctx, canvas);
				terrain.render(ctx, canvas);
				
				var infElement = document.getElementById('information');
				infElement.innerHTML = Date.now() - startTime + ' ms';
			}
			
			
			Terrain.prototype.generate = function(roughness) {
			
				var self = this;
			
				var currMax = this.max;
				var x, y;
			
				addRandomToAngles();
			
				while (currMax > 1) {
					for (y = currMax / 2; y < this.size; y += currMax) {
						for (x = currMax / 2; x < this.size; x += currMax) {
							countOneSquare(x, y, currMax);
						}					
					}
						
					for (y = 0; y < this.size; y += currMax) {
						for (x = currMax / 2; x < this.size; x += currMax) {
							countOneDiamond(x, y, currMax);							
						}
					}
					
					for (y = currMax / 2; y < this.size; y += currMax) {
						for (x = 0; x < this.size; x += currMax) {
							countOneDiamond(x, y, currMax);
						}					
					}
					
					currMax = currMax / 2;
				}
				
				normalize();
				
				var do2power = document.getElementById('do2power');				
				if (do2power.checked) {
					raiseToSecondPower();
				}
				
				function countOneSquare(x, y, currMax) {				
					self.map[x][y] = (self.map[x - currMax/2][y - currMax/2] +
									  self.map[x + currMax/2][y - currMax/2] + 
									  self.map[x + currMax/2][y + currMax/2] + 
									  self.map[x + currMax/2][y + currMax/2]) / 4 +
															randomAdd(roughness, currMax);
				}
		
				function countOneDiamond(x, y, currMax) {
					var roughness = getValue('roughness');
					var outsideHeight = getValue('outsideHeight');
					
					var halfSize = currMax / 2;
				
					self.map[x][y] = (getHeight(x, y - halfSize) + getHeight(x + halfSize, y) +
										getHeight(x, y + halfSize) + getHeight(x - halfSize, y)) / 4 +
										randomAdd(roughness, currMax);
				
					function getHeight(xCoord, yCoord) {
						if(xCoord < 0 || xCoord > self.max || yCoord < 0 || yCoord > self.max) return outsideHeight;	
							return self.map[xCoord][yCoord];
					}
				}
				
				function addRandomToAngles() {
					self.map[0][0] = Math.random() * self.max;
					self.map[0][self.max] = Math.random() * self.max;
					self.map[self.max][0] = Math.random() * self.max;
					self.map[self.max][self.max] = Math.random() * self.max;
				}
				
				function normalize() {
					var max = self.map[0][0];
				
					for (var i = 0; i < self.size; i++) {
						for (var j = 0; j < self.size; j++) {
							if (self.map[i][j] > max) {
								max = self.map[i][j];
							}
						}
					}				
					if (max == 0) return;
				
					for (var i = 0; i < self.size; i++) {
						for (var j = 0; j < self.size; j++) {
							self.map[i][j] /= max;
						}
					}
				}
					
				function randomAdd(roughness, currMax) {
					return (Math.random() * 2 - 1) * roughness * currMax;
				}
				
				function raiseToSecondPower() {
					for (var i = 0; i < self.map.length; i++) {
						for (var j = 0; j < self.map[i].length; j++) {
							self.map[i][j] *= self.map[i][j];
						}
					}
				}
			}			
		
			
			Terrain.prototype.defineColors = function() {
			
				var self = this;
			
				var waterLevel = getValue('waterLevel');
				
				var initR, finR, initG, finG, initB, finB;
				getColorValues();
				
				var RGBcolors = {R: '00', G: '00', B: '00'};
				
				for (var i = 0; i < this.size; i++) {
					for(var j = 0; j < this.size; j++) {
						if (this.map[i][j] <= waterLevel) {
							this.colors[i][j] = 'blue';
						} else {
						
							RGBcolors.R = getColorComponent(initR, finR);
							RGBcolors.G = getColorComponent(initG, finG);
							RGBcolors.B = getColorComponent(initB, finB);
							
							this.colors[i][j] = '#' + RGBcolors.R + RGBcolors.G + RGBcolors.B;
						}
					}
				}
				
				function getColorValues() {
					initR = getValue('initRcolor');	
					finR = getValue('finRcolor');
				
					initG = getValue('initGcolor');
					finG = getValue('finGcolor');
				
					initB = getValue('initBcolor');
					finB = getValue('finBcolor');	
				}
				
				function getColorComponent(init, fin) {
					var component = Math.floor((self.map[i][j] - waterLevel) / (1 - waterLevel) * (fin - init) + init);
					component = component.toString(16);
					if(component.length == 1) {
						component = '0' + component;
					}
					return component;
				}
			}
		
		
			Terrain.prototype.draw = function(ctx, canvas) {
				var cellSize = canvas.width / this.size; 		 //Считаем canvas квадратным
				for(var j = 0; j < this.size; j++) {
					for(var i = 0; i < this.size; i++) {
				
						var x = i * cellSize;
						var y = j * cellSize;
						
						ctx.fillStyle = this.colors[i][j];
						ctx.fillRect(x, y, cellSize, cellSize);
					}
				}
			}
			
			
			Terrain.prototype.render = function(ctx, canvas) {
				
				var self = this;
				var a = {};
			
				var cellSize = canvas.width / this.size; 		 //Считаем canvas квадратным
				for(var j = 0; j < this.size; j++) {
					for(var i = 0; i < this.size; i++) {
						a = iso(i, j);
						a.x = i * cellSize;
						a.y = j * cellSize;
						
						
						ctx.fillStyle = this.colors[i][j];
						ctx.fillRect(a.x, a.y, cellSize, cellSize);
					}
				}

				
				function iso(x, y) {
				  return {
					x: 0.5 * (self.size + x - y),
					y: 0.5 * (x + y)
				  };
				}
				
			}

			
			function checkFieldsAreCorrect() {
				var roughness = document.getElementById('roughness');
				return !isNaN(parseFloat(roughness.value)) && isFinite(roughness.value);
			}
					
			function getValue(elementId) {
				var element = document.getElementById(elementId);
				return +element.value;
			}
		
		
		</script>
	</body>
</html>
